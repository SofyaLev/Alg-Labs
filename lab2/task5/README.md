# Задача 5: Представитель большинства

## Описание

В данной задаче реализован алгоритм для нахождения мажоритарного элемента в массиве — элемента, который встречается более чем n/2 раз, где n — количество элементов в массиве. Используется метод Бойера-Мура, который позволяет определить наличие такого элемента за линейное время O(n) и константную дополнительную память O(1). Основная цель задачи — эффективно определить, существует ли мажоритарный элемент в заданном массиве, и вернуть его, если он существует.

## Структура проекта
```
Task5/
├── src/
│   ├── input.txt
│   ├── majority_element.py
│   ├── output.txt
│   └── task5.py
└── tests/
    ├── test1.py
    ├── test2.py
    └── test3.py
```
### Описание файлов

- src/majority_element.py: Модуль с реализацией алгоритма Бойера-Мура для поиска мажоритарного элемента. Содержит функцию majority_element, которая возвращает 1, если мажоритарный элемент существует, и 0 в противном случае.
- src/task5.py: Основной скрипт для выполнения задачи. Читает данные из input.txt, выполняет поиск мажоритарного элемента и записывает результат в output.txt. Также включает код для тестирования производительности и использования памяти на различных типах данных.
- src/input.txt: Входной файл, содержащий количество элементов и сам массив чисел.
- src/output.txt: Выходной файл, содержащий результат поиска мажоритарного элемента (1 — элемент найден, 0 — элемент отсутствует).
- tests/test1.py: Тест с небольшим массивом для оценки производительности и использования памяти.
- tests/test2.py: Тест с массивом из одного элемента для проверки корректности обработки минимального размера данных.
- tests/test3.py: Тест с большим случайным массивом для проверки эффективности алгоритма на больших данных.

## Как запустить проект

### Установка зависимостей

Проект использует стандартную библиотеку Python. Для оценки использования памяти необходимо установить модуль psutil:
```
pip install psutil
```
### Запуск алгоритма поиска мажоритарного элемента

1. Перейдите в директорию Task5/src:
2. Убедитесь, что файл input.txt содержит корректные входные данные в следующем формате:
```
n
a1 a2 a3 ... an
```
- Первая строка: число n (1 ≤ n ≤ 10⁵) — количество элементов массива.
- Вторая строка: n целых чисел, разделённых пробелами — элементы массива.

3. Запустите скрипт поиска мажоритарного элемента.
4. Результат работы будет записан в файл output.txt в виде 1, если мажоритарный элемент существует, или 0 в противном случае.

### Запуск тестов

1. Перейдите в директорию с тестами.
2. Откройте необходимыйт файл. 
3. Запустите скрипт теста.

## Формат входных и выходных данных

### Входной файл (input.txt)
```
n
a1 a2 a3 ... an
```
- Первая строка: число n (1 ≤ n ≤ 10⁵) — количество элементов массива.
- Вторая строка: n целых чисел, по модулю не превосходящих 10⁹, разделённых пробелами — элементы массива.

### Выходной файл (output.txt)

```
1
```
или
```
0
```
- `1`: Мажоритарный элемент существует в массиве.
- `0`: Мажоритарный элемент отсутствует в массиве.

Если входные данные не соответствуют условиям, выводится сообщение:
```
Введенные данные не соответствуют условию
```
## Описание алгоритма

### Метод поиска мажоритарного элемента

Алгоритм позволяет за линейное время O(n) и константную дополнительную память O(1) определить, существует ли в массиве элемент, который встречается более чем n/2 раз.

#### Основные шаги алгоритма:
1. Нахождение кандидата на мажоритарный элемент:
    - Инициализируем счетчик count и переменную candidate.
    - Проходим по массиву:
        - Если count равен 0, устанавливаем текущий элемент как кандидата и увеличиваем count.
        - Если текущий элемент совпадает с кандидатом, увеличиваем count.
        - В противном случае уменьшаем count.
2. Проверка кандидата:
    - Подсчитываем количество вхождений кандидата в массив.
    - Если количество больше n/2, то кандидат является мажоритарным элементом.
    - В противном случае мажоритарный элемент отсутствует.

#### Функции

- find_candidate(array): Находит кандидата на мажоритарный элемент.
- is_majority(array, candidate): Проверяет, является ли кандидат мажоритарным элементом.
- majority_element(array): Определяет наличие мажоритарного элемента и возвращает 1 или 0.

### Основные характеристики

- Время работы: O(n) — линейная сложность по времени.
- Память: O(1) — константная дополнительная память.

## Тестирование

Для проверки корректности и эффективности алгоритма реализованы три теста:

1. test1.py: Тест с небольшим массивом для оценки времени выполнения и использования памяти.
2. test2.py: Тест с массивом из одного элемента для проверки корректности обработки минимального размера данных.
3. test3.py: Тест с большим случайным массивом (до 10⁵ элементов) для проверки производительности на больших данных.

### Запуск тестов

Каждый тестовый скрипт выполняет поиск мажоритарного элемента и выводит время выполнения и использование памяти.

## Примеры

### Пример 1: Успешный поиск мажоритарного элемента

Входной файл (`input.txt`):
```
5
2 3 9 2 2
```

Выходной файл (`output.txt`):
```
1
```
Объяснение:

В данном массиве элемент 2 встречается 3 раза, что больше 5/2 = 2.5, следовательно, мажоритарный элемент существует.

### Пример 2: Отсутствие мажоритарного элемента

Входной файл (`input.txt`):
```
4
1 2 3 4
```
Выходной файл (`output.txt`):
```
0
```
Объяснение:

В данном массиве ни один элемент не встречается более чем 4/2 = 2 раза, следовательно, мажоритарный элемент отсутствует.

### Пример 3: Некорректные данные

Входной файл (`input.txt`):
```
100000
1 2 3
```
Выходной файл (`output.txt`):
```
Введенные данные не соответствуют условию
```
Объяснение:

Число элементов n = 100000, но в массиве предоставлено только 3 элемента, что нарушает условие задачи.

## Оценка производительности

В основных скриптах файлов `test1`, `test2`, `test3` реализовано измерение времени выполнения и использования памяти для различных типов массивов:

- Маленький массив: Проверка быстродействия и памяти на небольшом наборе данных.
- Массив из одного элемента: Проверка корректности обработки минимального размера данных.
- Большой случайный массив: Оценка производительности на больших объемах данных.

### Пример вывода для малого массива:
```
Время: 0.0005 секунд
Память: 5.2 Мбайт
```
### Пример вывода для большого массива:
```
Время: 0.005556999999498657 секунд
Память: 19.05859375 Мбайт
```
## Заключение
Задача 5 демонстрирует эффективную реализацию алгоритма Бойера-Мура для поиска мажоритарного элемента в массиве. Алгоритм обеспечивает линейную сложность по времени и минимальное использование памяти, что делает его подходящим для обработки больших массивов данных. Тестирование подтверждает корректность и производительность алгоритма на различных типах входных данных, включая крайние случаи.
