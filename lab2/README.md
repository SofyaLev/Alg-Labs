# Лабораторная работа №2: Алгоритмы сортировки и поиска

## Описание

Данная лабораторная работа включает реализацию и тестирование нескольких алгоритмов сортировки и поиска, используемых в информатике для решения различных задач. Основные цели работы заключаются в изучении и применении методов сортировки, поиска, а также в применении подхода "разделяй и властвуй" для эффективного решения задач.

## Структура проекта
```
lab2/
│
├── task1/
│   ├── src/
│   │   ├── input.txt
│   │   ├── merge_sort.py
│   │   ├── output.txt
│   │   └── task1.py
│   └── tests/
│       ├── test1.py
│       ├── test2.py
│       └── test3.py
│
├── task2/
│   ├── src/
│   │   ├── input.txt
│   │   ├── merge_sort_indexes.py
│   │   ├── output.txt
│   │   └── task2.py
│   └── tests/
│       ├── test1.py
│       ├── test2.py
│       └── test3.py
│
├── task3/
│   ├── src/
│   │   ├── input.txt
│   │   ├── inversions_count.py
│   │   ├── output.txt
│   │   └── task3.py
│   └── tests/
│       ├── test1.py
│       ├── test2.py
│       └── test3.py
│
├── task4/
│   ├── src/
│   │   ├── binary_search.py
│   │   ├── input.txt
│   │   ├── output.txt
│   │   └── task4.py
│   └── tests/
│       ├── test1.py
│       └── test2.py
│
├── task5/
│   ├── src/
│   │   ├── input.txt
│   │   ├── majority_element.py
│   │   ├── output.txt
│   │   └── task5.py
│   └── tests/
│       ├── test1.py
│       ├── test2.py
│       └── test3.py
│
└── task7/
    ├── src/
    │   ├── find_max_subarray.py
    │   ├── input.txt
    │   ├── output.txt
    │   └── task7.py
    └── tests/
        ├── test1.py
        ├── test2.py
        └── test3.py
```
## Задачи

### Задача 1: Сортировка слиянием

Реализация алгоритма сортировки слиянием, который рекурсивно делит массив на две половины и затем объединяет их в отсортированном порядке.

### Задача 2: Сортировка слиянием +

Расширенная версия сортировки слиянием, где дополнительно выводятся индексы и значения подмассивов на этапе слияния для отслеживания процесса выполнения алгоритма.

### Задача 3: Подсчет инверсий в массиве

Алгоритм сортировки слиянием, модифицированный для подсчета количества инверсий в массиве. Инверсии — это пары элементов, которые стоят в неправильном порядке.

### Задача 4: Бинарный поиск

Реализация бинарного поиска в отсортированном массиве для нахождения индекса заданного элемента или определения, что элемент отсутствует в массиве.

### Задача 5: Представитель большинства

Алгоритм для нахождения элемента, который встречается более чем n/2 раз в массиве, используя метод Бойера-Мура.

### Задача 7: Поиск максимальной подпоследовательности за линейное время

Алгоритм для поиска непрерывной подпоследовательности в массиве, сумма элементов которой максимальна среди всех возможных подпоследовательностей, используя метод Кадане.

## Запуск проектов

Каждая из задач расположена в своей отдельной директории. В каждой директории имеются исходные файлы, входные данные (input.txt), выходные данные (output.txt) и тесты для проверки правильности работы алгоритмов.

### Общие шаги для запуска каждой задачи:

1. Установка зависимостей:

    Проект не требует дополнительных зависимостей, кроме стандартной библиотеки Python. Однако для оценки использования памяти необходимо установить модуль psutil:
```
pip install psutil
```

2. Запуск алгоритма:
    Перейдите в директорию с задачей (например, task1/src).
    Убедитесь, что файл input.txt содержит корректные данные в соответствии с форматом задачи.
    Запустите соответствующий скрипт Python для выполнения задачи.
    Результат работы будет записан в файл output.txt.

3. Запуск тестов:

    Перейдите в директорию с тестами (например, task1/tests).
    Откройте необходимыйт файл. 
    Запустите скрипт теста. 

## Формат входных и выходных данных
Каждая задача имеет свой формат входных и выходных данных, который подробно описан в соответствующих README файлов каждой задачи.

### Пример общего формата входных данных:
```
n
a1 a2 a3 ... an
```
- Первая строка: число n — количество элементов массива.
- Вторая строка: n целых чисел, разделённых пробелами.

### Пример общего формата выходных данных:
```
<результат>
```
- Формат результата зависит от конкретной задачи.

## Описание алгоритмов

Каждая задача реализует свой алгоритм с описанием функций и их назначения. Ниже приведены краткие описания используемых алгоритмов:

### Сортировка слиянием

Алгоритм сортировки слиянием работает по принципу "разделяй и властвуй". Он рекурсивно делит массив на две половины, сортирует каждую из них и затем объединяет в отсортированный массив.

### Бинарный поиск

Алгоритм бинарного поиска эффективно находит индекс заданного элемента в отсортированном массиве за логарифмическое время O(log n). Если элемент не найден, возвращается -1.

### Подсчет инверсий

Модифицированный алгоритм сортировки слиянием, который подсчитывает количество инверсий в массиве — пар элементов, стоящих в неправильном порядке.

### Представитель большинства

Алгоритм позволяет определить наличие элемента, который встречается более чем n/2 раз в массиве, за линейное время O(n) и константную память O(1).

### Поиск максимальной подпоследовательности за линейное время

Алгоритм Кадане позволяет найти непрерывную подпоследовательность с максимальной суммой элементов за линейное время O(n) и константную память O(1).

## Тестирование

Тесты разработаны для каждой задачи и включают проверку различных сценариев, таких как:

- Обычные массивы.
- Пустые массивы.
- Уже отсортированные массивы.
- Массивы в обратном порядке.
- Массивы с одним элементом.
- Большие массивы с максимальным размером.
- Некорректные входные данные.

Тестирование позволяет убедиться в корректности работы каждого из реализованных алгоритмов и их устойчивости к различным типам входных данных.

## Примеры

### Задача 5: Представитель большинства

Входной файл (`input.txt`):
```
5
2 3 9 2 2
```
Выходной файл (`output.txt`):
```
1
```
Объяснение:

В данном массиве элемент 2 встречается 3 раза, что больше 5/2 = 2.5, следовательно, мажоритарный элемент существует.

### Задача 7: Поиск максимальной подпоследовательности

Входной файл (`input.txt`):
```
4
1 8 2 10
```
Выходной файл (`output.txt`):
```
Максимальная сумма: 21, начальный индекс: 0, конечный индекс: 3
```
Объяснение:

В данном массиве максимальная подпоследовательность — [1, 8, 2, 10] с суммой 21, начиная с индекса 0 и заканчивая индексом 3.

## Оценка производительности

В каждом основном скрипте задач реализовано измерение времени выполнения и использования памяти для различных типов массивов:

- Маленькие массивы: Проверка быстродействия и использования памяти на небольших наборах данных.
- Массивы из одного элемента: Проверка корректности обработки минимального размера данных.
- Большие случайные массивы: Оценка производительности на больших объемах данных.

### Пример вывода для малого массива:
```
Время: 0.0012 секунд
Память: 15.3 Мбайт
```
### Пример вывода для большого массива:
```
Время: 0.010346500000196102 секунд
Память: 18.375 Мбайт
```
## Заключение

Лабораторная работа №2 демонстрирует эффективную реализацию различных алгоритмов сортировки и поиска, их корректность и производительность на различных типах данных. Тестирование подтверждает стабильную работу алгоритмов и их способность обрабатывать как небольшие, так и большие массивы данных с различными характеристиками.

# Краткий обзор каждой задачи

### Задача 1: Сортировка слиянием

- Функции: merge, merge_sort
- Цель: Реализовать и протестировать стандартный алгоритм сортировки слиянием.

### Задача 2: Сортировка слиянием +

- Функции: merge_indexes, merge_sort_indexes
- Цель: Реализовать модифицированный алгоритм сортировки слиянием с дополнительным выводом информации о процессе слияния.

### Задача 3: Подсчет инверсий в массиве
- Функции: inversions_merge, inversions_merge_sort
- Цель: Реализовать алгоритм подсчета инверсий с использованием сортировки слиянием.

### Задача 4: Бинарный поиск

- Функции: binary_search, search_elements
- Цель: Реализовать бинарный поиск для нахождения индексов заданных элементов в отсортированном массиве.

### Задача 5: Представитель большинства

- Функции: find_candidate, is_majority, majority_element
- Цель: Реализовать алгоритм для поиска мажоритарного элемента в массиве.

### Задача 7: Поиск максимальной подпоследовательности за линейное время

- Функции: find_max_subarray
- Цель: Реализовать алгоритм для поиска максимальной подпоследовательности в массиве.

## Рекомендации

- Проверка входных данных: Убедитесь, что входные данные соответствуют ожидаемому формату и ограничениям задачи перед запуском скриптов.
- Тестирование: Используйте предоставленные тесты для проверки корректности и эффективности реализованных алгоритмов. При необходимости добавляйте дополнительные тесты для покрытия различных сценариев.
- Оптимизация: Обратите внимание на использование памяти и время выполнения алгоритмов, особенно при работе с большими массивами данных.
