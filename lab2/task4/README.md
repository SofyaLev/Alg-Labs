# Задача 4: Бинарный поиск

## Описание

В данной задаче реализован алгоритм бинарного поиска для нахождения индексов заданных элементов в отсортированном массиве. Бинарный поиск — эффективный алгоритм поиска элемента в отсортированном массиве с временной сложностью O(log n). Основная цель задачи — продемонстрировать применение бинарного поиска для обработки большого объема запросов и оценить его производительность и использование памяти при различных типах данных.

## Структура проекта

```
Task4/
├── src/
│   ├── binary_search.py
│   ├── input.txt
│   ├── output.txt
│   └── task4.py
└── tests/
    ├── test1.py
    ├── test2.py
    └── test3.py
```
### Описание файлов

- src/binary_search.py: Реализация алгоритма бинарного поиска. Содержит функции binary_search и search_elements для поиска индексов заданных элементов.
- src/task4.py: Основной скрипт для выполнения задачи. Читает данные из input.txt, выполняет бинарный поиск для заданных элементов и записывает результаты в output.txt. Также включает код для тестирования производительности и использования памяти на различных типах данных.
- src/input.txt: Входной файл, содержащий размеры массивов и сами массивы чисел.
- src/output.txt: Выходной файл, содержащий индексы найденных элементов или -1, если элемент отсутствует в массиве.
- tests/test1.py: Тест с небольшим массивом и набором целей для оценки производительности и использования памяти.
- tests/test2.py: Тест с массивом из одного элемента и набором целей для проверки корректности обработки минимального размера данных.
- tests/test3.py: Тест с большим случайным массивом и набором целей для проверки эффективности алгоритма на больших данных.

## Как запустить проект

### Установка зависимостей

Проект использует стандартную библиотеку Python. Для оценки использования памяти необходимо установить модуль psutil:

```
pip install psutil
```
### Запуск алгоритма бинарного поиска

1. Перейдите в директорию Task4/src.
2. Убедитесь, что файл input.txt содержит корректные входные данные в следующем формате:
```
n
a1 a2 a3 ... an
k
b1 b2 b3 ... bk
```   

- Первая строка: число n (1 ≤ n ≤ 10⁵) — количество элементов в массиве.
- Вторая строка: n целых чисел, разделённых пробелами — отсортированный массив.
- Третья строка: число k (1 ≤ k ≤ 10⁵) — количество элементов для поиска.
- Четвёртая строка: k целых чисел, разделённых пробелами — элементы, индексы которых необходимо найти.
3. Запустите скрипт бинарного поиска.
4. Результат работы будет записан в файл output.txt в формате, где для каждого искомого элемента указан его индекс в массиве (начиная с 0) или -1, если элемент отсутствует.

### Запуск тестов

1. Перейдите в директорию с тестами.
2. Откройте необходимыйт файл. 
3. Запустите скрипт теста.

## Формат входных и выходных данных

### Входной файл (input.txt)
```
n
a1 a2 a3 ... an
k
b1 b2 b3 ... bk
```
- Первая строка: число n (1 ≤ n ≤ 10⁵) — количество элементов в массиве.
- Вторая строка: n целых чисел, по модулю не превосходящих 10⁹, разделённых пробелами — отсортированный массив.
- Третья строка: число k (1 ≤ k ≤ 10⁵) — количество элементов для поиска.
- Четвёртая строка: k целых чисел, по модулю не превосходящих 10⁹, разделённых пробелами — элементы, индексы которых необходимо найти.

### Выходной файл (output.txt)
```
i1, i2, i3, ..., ik
```
- `i1, i2, ..., ik`: Индексы найденных элементов в массиве. Если элемент не найден, вместо индекса указывается -1. Индексация начинается с 0.

Если входные данные не соответствуют условиям, выводится сообщение:
```
Введенные данные не соответствуют условию
```
## Описание алгоритма

### Бинарный поиск

Алгоритм бинарного поиска эффективно находит индекс заданного элемента в отсортированном массиве за логарифмическое время. Основные шаги алгоритма:
1. Инициализация: Устанавливаем левый (left) и правый (right) указатели на начало и конец массива соответственно.
2. Итерация:
    - Вычисляем средний индекс middle.
    - Сравниваем элемент в средней позиции с целевым элементом.
    - Если элемент совпадает, возвращаем его индекс.
    - Если целевой элемент меньше, продолжаем поиск в левой половине массива.
    - Если целевой элемент больше, продолжаем поиск в правой половине массива.
3. Завершение: Если элемент не найден, возвращаем -1.

#### Функции

- binary_search(array, target): Выполняет бинарный поиск элемента target в отсортированном массиве array. Возвращает индекс элемента или -1, если элемент не найден.

- search_elements(array, targets): Выполняет бинарный поиск для каждого элемента из списка targets в массиве array. Возвращает список индексов найденных элементов.

### Основные характеристики

- Время работы: O(k log n), где k — количество запросов, n — размер массива.
- Память: O(1) дополнительной памяти для каждого поиска.

## Тестирование

Для проверки корректности и эффективности алгоритма реализованы три теста:

1. test1.py: Тест с небольшим массивом и набором целей для оценки времени выполнения и использования памяти.
2. test2.py: Тест с массивом из одного элемента и набором целей для проверки корректности обработки минимального размера данных.
3. test3.py: Тест с большим случайным массивом и набором целей (до 10⁵ элементов) для проверки производительности на больших данных.

### Запуск тестов

Каждый тестовый скрипт выполняет бинарный поиск для заданных элементов и выводит время выполнения и использование памяти
## Примеры

### Пример 1: Успешный поиск элементов

Входной файл (`input.txt`):
```
5
1 5 8 12 13
5
8 1 23 1 11
```
Выходной файл (`output.txt`):

```
2, 0, -1, 0, -1
```
Объяснение:

- 8 находится на индексе 2.
- 1 находится на индексе 0.
- 23 отсутствует в массиве, возвращается -1.
- 1 снова находится на индексе 0.
- 11 отсутствует в массиве, возвращается -1.

### Пример 2: Некорректные данные

Входной файл (`input.txt`):
```
100000
1 2 3
```
Выходной файл (`output.txt`):
```
Введенные данные не соответствуют условию
```
## Оценка производительности

В основных скриптах файлов `test1`, `test2`, `test3` реализовано измерение времени выполнения и использования памяти для различных типов массивов:

- Маленький массив и набор целей: Проверка быстродействия и памяти на небольшом наборе данных.
- Массив из одного элемента и набор целей: Проверка корректности обработки минимального размера данных.
- Большой случайный массив и набор целей: Оценка производительности на больших объемах данных.

### Пример вывода для малого массива:
```
Время: 0.0012 секунд
Память: 15.3 Мбайт
```
### Пример вывода для большого массива:
```
Время: 0.182346100000359 секунд
Память: 23.859375 Мбайт
```
## Заключение

Задача 4 демонстрирует эффективную реализацию алгоритма бинарного поиска для нахождения индексов заданных элементов в отсортированном массиве. Алгоритм обеспечивает высокую производительность даже при большом объеме данных и большом количестве запросов. Тестирование подтверждает корректность и эффективность работы алгоритма на различных типах входных данных, включая крайние случаи.
